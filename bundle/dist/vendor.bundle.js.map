{"version":3,"sources":["webpack:///vendor.bundle.js","webpack:///webpack/bootstrap bdcb643d001a5e21d8e2","webpack:///./src/vendor.js","webpack:///./~/riot/riot.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/css/grid.css","webpack:///./src/css/style.css","webpack:///./src/css/tacit.min.css","webpack:///./src/css/grid.css?9644","webpack:///./src/css/style.css?21aa","webpack:///./src/css/tacit.min.css?4899","webpack:///(webpack)/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift",0,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","__WEBPACK_AMD_DEFINE_RESULT__","mkitem","expr","key","val","item","pos","unmountRedundant","items","tags","t","j","splice","unmount","moveNestedTags","child","Object","keys","forEach","tagName","tag","isArray","each","moveChildTag","addVirtual","target","sib","el","_root","_virts","nextSibling","insertBefore","moveVirtual","len","_each","dom","parent","remAttr","hasKeys","mustReorder","getAttr","T_STRING","getTagName","impl","__tagImpl","tmpl","outerHTML","useRoot","SPECIAL_TAGS_REGEX","test","root","parentNode","ref","createTextNode","getTag","isOption","oldItems","isVirtual","loopKeys","one","removeChild","stub","on","frag","createDocumentFragment","map","itemsLength","_mustReorder","oldPos","indexOf","Tag","isLoop","hasImpl","cloneNode","innerHTML","mount","firstChild","update","childNodes","_item","defineProperty","slice","parseNamedElements","childTags","forceParsingNamed","walk","nodeType","initChildTag","setNamed","parseExpressions","expressions","addExpr","extra","hasExpr","extend","attr","nodeValue","attributes","name","bool","split","value","conf","updateOpts","ctx","self","opts","toCamel","normalizeData","data","T_UNDEF","isWritable","inheritFromParent","k","mustSync","contains","RESERVED_WORDS_BLACKLIST","propsInSyncWithParent","toggle","isMount","evt","riot","observable","this","inherit","cleanUpData","fn","toLowerCase","implAttr","_tag","isMounted","__uid","mkdom","attrs","isObject","trigger","rAF","arguments","mix","instance","mixin","isFunction","prototype","getOwnPropertyNames","bind","init","globalMixin","GLOBAL_MIXIN","walkAttributes","v","setAttr","isInStub","keepRootTag","ptag","tagIndex","__virtualDom","getImmediateCustomParentTag","_riot_id","off","setEventHandler","handler","_parent","event","currentTarget","srcElement","which","charCode","keyCode","preventDefault","returnValue","preventUpdate","insertTo","node","before","attrName","IE_VERSION","add","remove","inStub","style","display","nodeName","T_OBJECT","startsWith","RIOT_PREFIX","RIOT_TAG","els","T_FUNCTION","removeAttribute","string","replace","_","toUpperCase","getAttribute","setAttribute","addChildTag","cachedTag","newPos","options","enumerable","writable","configurable","namedTag","obj","args","arr","a","Array","props","getOwnPropertyDescriptor","o","html","re","exec","mkEl","$$","selector","querySelectorAll","$","querySelector","Child","getNamedKey","isArr","str","mountTo","_innerHTML","version","settings","documentMode","onEachEvent","defineProperties","events","typed","cb","fns","arglen","busy","concat","DEFAULT_PARSER","path","DEFAULT_SECOND_PARSER","filter","RegExp","REPLACE","match","debounce","delay","clearTimeout","setTimeout","start","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","doc","clickEvent","click","Router","central","s","normalize","isString","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","current","TRIGGER","metaKey","ctrlKey","shiftKey","defaultPrevented","HAS_ATTRIBUTE","go","title","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","history","location","prot","ontouchstart","started","first","second","third","r","some","action","mainRouter","route","create","newSubRouter","stop","arg","fn2","query","q","readyState","brackets","UNDEF","_loopback","_rewrite","bp","_cache","source","global","REGLOB","_create","pair","DEFAULT","_pairs","Error","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","set","get","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","index","trim","hasRaw","array","_tmpl","_logErr","err","errorHandler","riotData","_getTmpl","Function","qstr","list","_parseExpr","join","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","cnt","CS_IDENT","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","haveRaw","parse","checkIE","_mkdom","templ","replaceYield","tblTags","specialTags","select","selectedIndex","tname","rootEls","reHasYield","n","reYieldDest","def","rsYieldSrc","reYieldCls","reYieldAll","tr","th","td","col","styleManager","_riot","inject","styleNode","newNode","userNode","replaceChild","cssTextProp","styleSheet","stylesToInject","css","cssText","w","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","navigator","userAgent","lastTime","nowtime","Date","now","timeout","Math","max","util","mixins","tag2","bpair","addRiotTags","selectAllTags","pushTags","riotTag","allTags","nodeList","_el","toString","result","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","addStyle","listToStyles","newStyles","media","sourceMap","part","createStyleElement","styleElement","getHeadElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","applyToTag","newObj","replaceText","cssNode","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","memo","isOldIE","newList","mayRemove","textStore","replacement","Boolean","content","locals","__webpack_amd_options__"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!***********************!*\\\n  !*** ./src/vendor.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(/*! ./css/tacit.min.css */ 25);\n\t\n\t__webpack_require__(/*! ./css/style.css */ 24);\n\t\n\t__webpack_require__(/*! ./css/grid.css */ 23);\n\t\n\t__webpack_require__(/*! riot */ 1);\n\n/***/ },\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.3.16, @license MIT */\n\t\n\t;(function(window, undefined) {\n\t  'use strict';\n\tvar riot = { version: 'v2.3.16', settings: {} },\n\t  // be aware, internal usage\n\t  // ATTENTION: prefix the global dynamic variables with `__`\n\t\n\t  // counter to give a unique id to all the Tag instances\n\t  __uid = 0,\n\t  // tags instances cache\n\t  __virtualDom = [],\n\t  // tags implementation cache\n\t  __tagImpl = {},\n\t\n\t  /**\n\t   * Const\n\t   */\n\t  GLOBAL_MIXIN = '__global_mixin',\n\t\n\t  // riot specific prefixes\n\t  RIOT_PREFIX = 'riot-',\n\t  RIOT_TAG = RIOT_PREFIX + 'tag',\n\t\n\t  // for typeof == '' comparisons\n\t  T_STRING = 'string',\n\t  T_OBJECT = 'object',\n\t  T_UNDEF  = 'undefined',\n\t  T_FUNCTION = 'function',\n\t  // special native tags that cannot be treated like the others\n\t  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n\t  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\t\n\t  // version# for IE 8-11, 0 for others\n\t  IE_VERSION = (window && window.document || {}).documentMode | 0\n\t/* istanbul ignore next */\n\triot.observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables and methods\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice,\n\t    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) }\n\t\n\t  // extend the object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n\t     * @param  { String } events - events ids\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(events, fn) {\n\t        if (typeof fn != 'function')  return el\n\t\n\t        onEachEvent(events, function(name, pos) {\n\t          (callbacks[name] = callbacks[name] || []).push(fn)\n\t          fn.typed = pos > 0\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given space separated list of `events` listeners\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(events, fn) {\n\t        if (events == '*' && !fn) callbacks = {}\n\t        else {\n\t          onEachEvent(events, function(name) {\n\t            if (fn) {\n\t              var arr = callbacks[name]\n\t              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t                if (cb == fn) arr.splice(i--, 1)\n\t              }\n\t            } else delete callbacks[name]\n\t          })\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given space separated list of `events` and execute the `callback` at most once\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(events, fn) {\n\t        function on() {\n\t          el.off(events, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(events, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to the given space separated list of `events`\n\t     * @param   { String } events - events ids\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(events) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns\n\t\n\t        for (var i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        onEachEvent(events, function(name) {\n\t\n\t          fns = slice.call(callbacks[name] || [], 0)\n\t\n\t          for (var i = 0, fn; fn = fns[i]; ++i) {\n\t            if (fn.busy) return\n\t            fn.busy = 1\n\t            fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t            if (fns[i] !== fn) { i-- }\n\t            fn.busy = 0\n\t          }\n\t\n\t          if (callbacks['*'] && name != '*')\n\t            el.trigger.apply(el, ['*', name].concat(args))\n\t\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t/* istanbul ignore next */\n\t;(function(riot) {\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\t\n\tvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n\t  EVENT_LISTENER = 'EventListener',\n\t  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n\t  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n\t  HAS_ATTRIBUTE = 'hasAttribute',\n\t  REPLACE = 'replace',\n\t  POPSTATE = 'popstate',\n\t  HASHCHANGE = 'hashchange',\n\t  TRIGGER = 'trigger',\n\t  MAX_EMIT_STACK_LEVEL = 3,\n\t  win = typeof window != 'undefined' && window,\n\t  doc = typeof document != 'undefined' && document,\n\t  hist = win && history,\n\t  loc = win && (hist.location || win.location), // see html5-history-api\n\t  prot = Router.prototype, // to minify more\n\t  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n\t  started = false,\n\t  central = riot.observable(),\n\t  routeFound = false,\n\t  debouncedEmit,\n\t  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n\t    args = path.match(re)\n\t\n\t  if (args) return args.slice(1)\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t\n\t  return function () {\n\t    clearTimeout(t)\n\t    t = setTimeout(fn, delay)\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1)\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click)\n\t  if (autoExec) emit(true)\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = []\n\t  riot.observable(this) // make it observable\n\t  central.on('stop', this.s.bind(this))\n\t  central.on('emit', this.e.bind(this))\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path[REPLACE](/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href || '')[REPLACE](RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] == '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : getPathFromRoot(href)[REPLACE](base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel == 0\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\t\n\t  emitStackLevel++\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase()\n\t    if (force || path != current) {\n\t      central[TRIGGER]('emit', path)\n\t      current = path\n\t    }\n\t  })\n\t  if (isRoot) {\n\t    while (emitStack.length) {\n\t      emitStack[0]()\n\t      emitStack.shift()\n\t    }\n\t    emitStackLevel = 0\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which != 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) return\n\t\n\t  var el = e.target\n\t  while (el && el.nodeName != 'A') el = el.parentNode\n\t  if (\n\t    !el || el.nodeName != 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target != '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n\t  ) return\n\t\n\t  if (el.href != loc.href) {\n\t    if (\n\t      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n\t      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    ) return\n\t  }\n\t\n\t  e.preventDefault()\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  if (hist) { // if a browser\n\t    path = base + normalize(path)\n\t    title = title || doc.title\n\t    // browsers ignores the second parameter `title`\n\t    shouldReplace\n\t      ? hist.replaceState(null, title, path)\n\t      : hist.pushState(null, title, path)\n\t    // so we need to set it manually\n\t    doc.title = title\n\t    routeFound = false\n\t    emit()\n\t    return routeFound\n\t  }\n\t\n\t  // Server-side usage: directly execute handlers for the path\n\t  return central[TRIGGER]('emit', getPathFromBase(path))\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n\t  else if (second) this.r(first, second)\n\t  else this.r('@', first)\n\t}\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*')\n\t  this.$ = []\n\t}\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args))\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this)\n\t}\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter != '@') {\n\t    filter = '/' + normalize(filter)\n\t    this.$.push(filter)\n\t  }\n\t  this.on(filter, action)\n\t}\n\t\n\tvar mainRouter = new Router()\n\tvar route = mainRouter.m.bind(mainRouter)\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router()\n\t  // stop only this sub-router\n\t  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n\t  // return sub-router's main method\n\t  return newSubRouter.m.bind(newSubRouter)\n\t}\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#'\n\t  current = getPathFromBase() // recalculate current path\n\t}\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true)\n\t}\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER\n\t    secondParser = DEFAULT_SECOND_PARSER\n\t  }\n\t  if (fn) parser = fn\n\t  if (fn2) secondParser = fn2\n\t}\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {}\n\t  var href = loc.href || current\n\t  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n\t  return q\n\t}\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n\t    }\n\t    central[TRIGGER]('stop')\n\t    started = false\n\t  }\n\t}\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState == 'complete') start(autoExec)\n\t      // the timeout is needed to solve\n\t      // a weird safari bug https://github.com/riot/route/issues/33\n\t      else win[ADD_EVENT_LISTENER]('load', function() {\n\t        setTimeout(function() { start(autoExec) }, 1)\n\t      })\n\t    }\n\t    started = true\n\t  }\n\t}\n\t\n\t/** Prepare the router **/\n\troute.base()\n\troute.parser()\n\t\n\triot.route = route\n\t})(riot)\n\t/* istanbul ignore next */\n\t\n\t/**\n\t * The riot template engine\n\t * @version v2.3.21\n\t */\n\t\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }'\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ]\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) bp = _cache\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) return _pairs\n\t\n\t    var arr = pair.split(' ')\n\t\n\t    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n\t    arr[6] = _rewrite(_pairs[6], arr)\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n\t    arr[8] = pair\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) _bp = _cache\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6]\n\t\n\t    isexpr = start = re.lastIndex = 0\n\t\n\t    while (match = re.exec(str)) {\n\t\n\t      pos = match.index\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n\t          continue\n\t        }\n\t        if (!match[3])\n\t          continue\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos))\n\t        start = re.lastIndex\n\t        re = _bp[6 + (isexpr ^= 1)]\n\t        re.lastIndex = start\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start))\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr)\n\t        parts.push(s && s.replace(_bp[5], '$1'))\n\t      else\n\t        parts.push(s)\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch]\n\t\n\t      recch.lastIndex = ix\n\t      ix = 1\n\t      while (match = recch.exec(s)) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) break\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  }\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  }\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9])\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  }\n\t\n\t  _brackets.hasRaw = function (src) {\n\t    return _cache[10].test(src)\n\t  }\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  }\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair)\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite\n\t      _cache[9] = _regex(_pairs[9])\n\t      _cache[10] = _regex(_pairs[10])\n\t    }\n\t    cachedBrackets = pair\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b\n\t    o = o || {}\n\t    b = o.brackets\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    })\n\t    _settings = o\n\t    _reset(b)\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  })\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n\t  _brackets.set = _reset\n\t\n\t  _brackets.R_STRINGS = R_STRINGS\n\t  _brackets.R_MLCOMMS = R_MLCOMMS\n\t  _brackets.S_QBLOCKS = S_QBLOCKS\n\t\n\t  return _brackets\n\t\n\t})()\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {}\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) return str\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.haveRaw = brackets.hasRaw\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys\n\t\n\t  _tmpl.errorHandler = null\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    if (_tmpl.errorHandler) {\n\t\n\t      err.riotData = {\n\t        tagName: ctx && ctx.root && ctx.root.tagName,\n\t        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t      }\n\t      _tmpl.errorHandler(err)\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t\n\t    var expr = _getTmpl(str)\n\t    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\t\n\t    return new Function('E', expr + ';')\n\t  }\n\t\n\t  var\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_QBMARK = /\\x01(\\d+)~/g\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = []\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i]\n\t\n\t        if (expr && (expr = i & 1 ?\n\t\n\t              _parseExpr(expr, 1, qstr) :\n\t\n\t              '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) list[j++] = expr\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0] :\n\t             '[' + list.join(',') + '].join(\"\")'\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr)\n\t    }\n\t\n\t    if (qstr[0])\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      })\n\t\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    },\n\t    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    if (expr[0] === '=') expr = expr.slice(1)\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match\n\t\n\t      while (expr &&\n\t            (match = expr.match(CS_IDENT)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g\n\t\n\t        expr = RegExp.rightContext\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\t\n\t        jsb  = expr.slice(0, match.index)\n\t        expr = RegExp.rightContext\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key)\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText) :\n\t          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch]\n\t\n\t      ir.lastIndex = re.lastIndex\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) ++lv\n\t        else if (!--lv) break\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n\t          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos))\n\t        }\n\t      }\n\t      return match\n\t    })\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb ?\n\t          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"'\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb ?\n\t          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)'\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  // istanbul ignore next: compatibility fix for beta versions\n\t  _tmpl.parse = function (s) { return s }\n\t\n\t  _tmpl.version = brackets.version = 'v2.3.21'\n\t\n\t  return _tmpl\n\t\n\t})()\n\t\n\t/*\n\t  lib/browser/tag/mkdom.js\n\t\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\tvar mkdom = (function (checkIE) {\n\t  var\n\t    reHasYield  = /<yield\\b/i,\n\t    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n\t    reYieldCls  = /<yield\\s+to=[^>]+>[\\S\\s]*?<\\/yield\\s*>\\s*/ig,\n\t    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n\t    rsYieldSrc  = '<yield\\\\s+to=[\\'\"]@[\\'\"]\\\\s*>([\\\\S\\\\s]*?)</yield\\\\s*>',\n\t    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' }\n\t\n\t  checkIE = checkIE && checkIE < 10\n\t  var tblTags = checkIE\n\t    ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\t\n\t  /**\n\t   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t   *\n\t   * @param   {string} impl   - Tag implementation with the template and root attributes\n\t   * @param   {string} [html] - HTML content that comes from the DOM element where you\n\t   *           will mount the tag, mostly the original tag in the page\n\t   * @param   {object} [attr] - Plain object where to store the root attributes\n\t   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n\t   */\n\t  function _mkdom(impl, html, attr) {\n\t\n\t    var templ = impl.tmpl,\n\t      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n\t      tagName = match && match[1].toLowerCase(),\n\t      el = mkEl('div')\n\t\n\t    if (!html) html = ''\n\t\n\t    if (impl.attrs) attr.attrs = replaceYield(impl.attrs, html)\n\t\n\t    // replace all the yield tags with the tag inner html\n\t    templ = replaceYield(templ, html)\n\t\n\t    /* istanbul ignore next */\n\t    if (tblTags.test(tagName))\n\t      el = specialTags(el, templ, tagName)\n\t    else\n\t      el.innerHTML = templ\n\t\n\t    el.stub = true\n\t\n\t    return el\n\t  }\n\t\n\t  /*\n\t    Creates the root element for table or select child elements:\n\t    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t  */\n\t  function specialTags(el, templ, tagName) {\n\t    var\n\t      select = tagName[0] === 'o',\n\t      parent = select ? 'select>' : 'table>'\n\t\n\t    // trim() is important here, this ensures we don't have artifacts,\n\t    // so we can check if we have only one element inside the parent\n\t    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n\t    parent = el.firstChild\n\t\n\t    // returns the immediate parent if tr/th/td/col is the only element, if not\n\t    // returns the whole tree, as this can include additional elements\n\t    if (select) {\n\t      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n\t    } else {\n\t      var tname = rootEls[tagName]\n\t      if (tname && parent.childNodes.length === 1) parent = $(tname, parent)\n\t    }\n\t    return parent\n\t  }\n\t\n\t  /*\n\t    Replace the yield tag from any tag template with the innerHTML of the\n\t    original tag in the page\n\t  */\n\t  function replaceYield(templ, html) {\n\t    // do nothing if no yield\n\t    if (!reHasYield.test(templ)) return templ\n\t\n\t    // be careful with #1343 - string on the source having `$1`\n\t    var n = 1\n\t    templ = templ.replace(reYieldDest, function (_, ref, def) {\n\t      var m = html.match(RegExp(rsYieldSrc.replace('@', ref), 'i'))\n\t      n = 0\n\t      return (m ? m[1] : def) || ''\n\t    })\n\t\n\t    // yield without any \"from\", replace yield in templ with the innerHTML\n\t    if (n || reHasYield.test(templ)) {\n\t      if (html) html = html.replace(reYieldCls, '').trim()\n\t      templ = templ.replace(reYieldAll, function (_, def) {\n\t        return html || def || ''\n\t      })\n\t    }\n\t\n\t    return templ\n\t  }\n\t\n\t  return _mkdom\n\t\n\t})(IE_VERSION)\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t\n\t\n\t  while (i > j) {\n\t    t = tags[--i]\n\t    tags.splice(i, 1)\n\t    t.unmount()\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @param   { Object } child - non custom loop tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(child, i) {\n\t  Object.keys(child.tags).forEach(function(tagName) {\n\t    var tag = child.tags[tagName]\n\t    if (isArray(tag))\n\t      each(tag, function (t) {\n\t        moveChildTag(t, tagName, i)\n\t      })\n\t    else\n\t      moveChildTag(tag, tagName, i)\n\t  })\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @param { Tag } tag - the tag whose root's children will be inserted or appended\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction addVirtual(tag, src, target) {\n\t  var el = tag._root, sib\n\t  tag._virts = []\n\t  while (el) {\n\t    sib = el.nextSibling\n\t    if (target)\n\t      src.insertBefore(el, target._root)\n\t    else\n\t      src.appendChild(el)\n\t\n\t    tag._virts.push(el) // hold for unmounting\n\t    el = sib\n\t  }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @param { Tag } tag - first child reference used to start move\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t * @param { Number } len - how many child nodes to move\n\t */\n\tfunction moveVirtual(tag, src, target, len) {\n\t  var el = tag._root, sib, i = 0\n\t  for (; i < len; i++) {\n\t    sib = el.nextSibling\n\t    src.insertBefore(el, target._root)\n\t    el = sib\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { Object } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each')\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n\t    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n\t    root = dom.parentNode,\n\t    ref = document.createTextNode(''),\n\t    child = getTag(dom),\n\t    isOption = /^option$/i.test(tagName), // the option tags must be treated differently\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isVirtual = dom.tagName == 'VIRTUAL'\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr)\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  root.insertBefore(ref, dom)\n\t\n\t  // clean template code\n\t  parent.one('before-mount', function () {\n\t\n\t    // remove the original DOM node\n\t    dom.parentNode.removeChild(dom)\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function () {\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      // create a fragment to hold the new DOM nodes to inject in the parent tag\n\t      frag = document.createDocumentFragment()\n\t\n\t\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, key, items[key])\n\t        }) : []\n\t    }\n\t\n\t    // loop all the new items\n\t    var i = 0,\n\t      itemsLength = items.length\n\t\n\t    for (; i < itemsLength; i++) {\n\t      // reorder only if the items are objects\n\t      var\n\t        item = items[i],\n\t        _mustReorder = mustReorder && item instanceof Object && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos]\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        tag = new Tag(impl, {\n\t          parent: parent,\n\t          isLoop: true,\n\t          hasImpl: !!__tagImpl[tagName],\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML)\n\t\n\t        tag.mount()\n\t        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n\t        // this tag must be appended\n\t        if (i == tags.length || !tags[i]) { // fix 1581\n\t          if (isVirtual)\n\t            addVirtual(tag, frag)\n\t          else frag.appendChild(tag.root)\n\t        }\n\t        // this tag must be insert\n\t        else {\n\t          if (isVirtual)\n\t            addVirtual(tag, root, tags[i])\n\t          else root.insertBefore(tag.root, tags[i].root)\n\t          oldItems.splice(i, 0, item)\n\t        }\n\t\n\t        tags.splice(i, 0, tag)\n\t        pos = i // handled here so no move\n\t      } else tag.update(item)\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (\n\t        pos !== i && _mustReorder &&\n\t        tags[i] // fix 1581 unable to reproduce it in a test!\n\t      ) {\n\t        // update the DOM\n\t        if (isVirtual)\n\t          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n\t        else root.insertBefore(tag.root, tags[i].root)\n\t        // update the position attribute if it exists\n\t        if (expr.pos)\n\t          tag[expr.pos] = i\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0])\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) moveNestedTags(tag, i)\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent)\n\t    }\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags)\n\t\n\t    // insert the new nodes\n\t    if (isOption) root.appendChild(frag)\n\t    else root.insertBefore(frag, ref)\n\t\n\t    // set the 'tags' property of the parent tag\n\t    // if child is 'undefined' it means that we don't need to set this property\n\t    // for example:\n\t    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n\t    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n\t    if (child) parent.tags[tagName] = tags\n\t\n\t    // clone the items array\n\t    oldItems = items.slice()\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = (function(_riot) {\n\t\n\t  if (!window) return { // skip injection on the server\n\t    add: function () {},\n\t    inject: function () {}\n\t  }\n\t\n\t  var styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style')\n\t    setAttr(newNode, 'type', 'text/css')\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]')\n\t    if (userNode) {\n\t      if (userNode.id) newNode.id = userNode.id\n\t      userNode.parentNode.replaceChild(newNode, userNode)\n\t    }\n\t    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\t\n\t    return newNode\n\t  })()\n\t\n\t  // Create cache and shortcut to the correct property\n\t  var cssTextProp = styleNode.styleSheet,\n\t    stylesToInject = ''\n\t\n\t  // Expose the style node in a non-modificable property\n\t  Object.defineProperty(_riot, 'styleNode', {\n\t    value: styleNode,\n\t    writable: true\n\t  })\n\t\n\t  /**\n\t   * Public api\n\t   */\n\t  return {\n\t    /**\n\t     * Save a tag style to be later injected into DOM\n\t     * @param   { String } css [description]\n\t     */\n\t    add: function(css) {\n\t      stylesToInject += css\n\t    },\n\t    /**\n\t     * Inject all previously saved tag styles into DOM\n\t     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t     */\n\t    inject: function() {\n\t      if (stylesToInject) {\n\t        if (cssTextProp) cssTextProp.cssText += stylesToInject\n\t        else styleNode.innerHTML += stylesToInject\n\t        stylesToInject = ''\n\t      }\n\t    }\n\t  }\n\t\n\t})(riot)\n\t\n\t\n\tfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop ||\n\t                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n\t                    ? 1 : 0\n\t\n\t      // custom child tag\n\t      if (childTags) {\n\t        var child = getTag(dom)\n\t\n\t        if (child && !dom.isLoop)\n\t          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n\t      }\n\t\n\t      if (!dom.isLoop || forceParsingNamed)\n\t        setNamed(dom, tag, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (tmpl.hasExpr(val)) {\n\t      expressions.push(extend({ dom: dom, expr: val }, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType,\n\t      attr\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    attr = getAttr(dom, 'each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t    opts = inherit(conf.opts) || {},\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    hasImpl = conf.hasImpl,\n\t    item = cleanUpData(conf.item),\n\t    expressions = [],\n\t    childTags = [],\n\t    root = conf.root,\n\t    fn = impl.fn,\n\t    tagName = root.tagName.toLowerCase(),\n\t    attr = {},\n\t    implAttr = {},\n\t    propsInSyncWithParent = [],\n\t    dom\n\t\n\t  if (fn && root._tag) root._tag.unmount(true)\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (tmpl.hasExpr(val)) attr[el.name] = val\n\t  })\n\t\n\t  dom = mkdom(impl, innerHTML, implAttr)\n\t  implAttr = implAttr.attrs || ''\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      var val = el.value\n\t      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[toCamel(name)] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  defineProperty(this, 'update', function(data) {\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (data && isObject(item)) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t    // the updated event will be triggered\n\t    // once the DOM will be ready and all the reflows are completed\n\t    // this is useful if you want to get the \"real\" root properties\n\t    // 4 ex: root.offsetWidth ...\n\t    if (self.parent)\n\t      // closes #1599\n\t      self.parent.one('updated', function() { self.trigger('updated') })\n\t    else rAF(function() { self.trigger('updated') })\n\t\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mixin', function() {\n\t    each(arguments, function(mix) {\n\t      var instance\n\t\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix()\n\t        // save the prototype to loop it afterwards\n\t        mix = mix.prototype\n\t      } else instance = mix\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(Object.getOwnPropertyNames(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(instance[key]) ?\n\t                        instance[key].bind(self) :\n\t                        instance[key]\n\t      })\n\t\n\t      // init method will be called automatically\n\t      if (instance.init) instance.init.bind(self)()\n\t    })\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mount', function() {\n\t\n\t    updateOpts()\n\t\n\t    // add global mixin\n\t    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n\t    if (globalMixin) self.mixin(globalMixin)\n\t\n\t    // initialiation\n\t    if (fn) fn.call(self, opts)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    // mount the child tags\n\t    toggle(true)\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    // it fixes also #1087\n\t    if (implAttr || hasImpl) {\n\t      walkAttributes(implAttr, function (k, v) { setAttr(root, k, v) })\n\t      parseExpressions(self.root, self, expressions)\n\t    }\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('before-mount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      root = dom.firstChild\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) root = parent.root\n\t    }\n\t\n\t    defineProperty(self, 'root', root)\n\t\n\t    // parse the named dom nodes in the looped child\n\t    // adding them to the parent as well\n\t    if (isLoop)\n\t      parseNamedElements(self.root, self.parent, null, true)\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  })\n\t\n\t\n\t  defineProperty(this, 'unmount', function(keepRootTag) {\n\t    var el = root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __virtualDom.indexOf(self)\n\t\n\t    self.trigger('before-unmount')\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      __virtualDom.splice(tagIndex, 1)\n\t\n\t    if (this._virts) {\n\t      each(this._virts, function(v) {\n\t        if (v.parentNode) v.parentNode.removeChild(v)\n\t      })\n\t    }\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(ptag.tags[tagName]))\n\t          each(ptag.tags[tagName], function(tag, i) {\n\t            if (tag._riot_id == self._riot_id)\n\t              ptag.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          ptag.tags[tagName] = undefined\n\t      }\n\t\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t      else\n\t        // the riot-tag attribute isn't needed anymore, remove it\n\t        remAttr(p, 'riot-tag')\n\t    }\n\t\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    self.isMounted = false\n\t    delete root._tag\n\t\n\t  })\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (!parent) return\n\t    var evt = isMount ? 'on' : 'off'\n\t\n\t    // the loop tags will be always in sync with the parent automatically\n\t    if (isLoop)\n\t      parent[evt]('unmount', self.unmount)\n\t    else\n\t      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n\t  }\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t}\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var ptag = tag._parent,\n\t      item = tag._item,\n\t      el\n\t\n\t    if (!item)\n\t      while (ptag && !item) {\n\t        item = ptag._item\n\t        ptag = ptag._parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // override the event properties\n\t    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n\t    if (isWritable(e, 'target')) e.target = e.srcElement\n\t    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      if (e.preventDefault) e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      el = item ? getImmediateCustomParentTag(ptag) : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t\n\t/**\n\t * Insert a DOM node replacing another one (used by if- attribute)\n\t * @param   { Object } root - parent node\n\t * @param   { Object } node - node replaced\n\t * @param   { Object } before - node added\n\t */\n\tfunction insertTo(root, node, before) {\n\t  if (!root) return\n\t  root.insertBefore(before, node)\n\t  root.removeChild(node)\n\t}\n\t\n\t/**\n\t * Update the expressions in a Tag instance\n\t * @param   { Array } expressions - expression that must be re evaluated\n\t * @param   { Tag } tag - tag instance\n\t */\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t      attrName = expr.attr,\n\t      value = tmpl(expr.expr, tag),\n\t      parent = expr.dom.parentNode\n\t\n\t    if (expr.bool)\n\t      value = !!value\n\t    else if (value == null)\n\t      value = ''\n\t\n\t    // textarea and text nodes has no attribute name\n\t    if (!attrName) {\n\t      // about #815 w/o replace: the browser converts the value to a string,\n\t      // the comparison by \"==\" does too, but not in the server\n\t      value += ''\n\t      // test for parent avoids error with invalid assignment to nodeValue\n\t      if (parent && dom.nodeValue != value) {\n\t        if (parent.tagName === 'TEXTAREA') {\n\t          parent.value = value                    // #1113\n\t          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n\t        }                                         // will be available on 'updated'\n\t        else dom.nodeValue = value\n\t      }\n\t      return\n\t    }\n\t\n\t    // #1612: look for changes in dom.value when updating the value\n\t    if (attrName === 'value') {\n\t      if (dom.value != value) dom.value = value\n\t      return\n\t    }\n\t\n\t    // was the expression value still the same?\n\t    if (expr.value === value) {\n\t      return\n\t    }\n\t    expr.value = value\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub,\n\t        add = function() { insertTo(stub.parentNode, stub, dom) },\n\t        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          add()\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted)\n\t                el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        // if the parentNode is defined we can easily replace the tag\n\t        if (dom.parentNode)\n\t          remove()\n\t        // otherwise we need to wait the updated event\n\t        else (tag.parent || tag).one('updated', remove)\n\t\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (attrName === 'show') {\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    } else if (attrName === 'hide') {\n\t      dom.style.display = value ? 'none' : ''\n\t\n\t    } else if (expr.bool) {\n\t      if (value) {\n\t        // #1374 <select> <option selected={true}> </select>\n\t        if (attrName === 'selected' && dom.nodeName === 'OPTION' && parent) {\n\t          parent.value = dom.value\n\t        }\n\t        setAttr(dom, attrName, attrName)\n\t      }\n\t\n\t    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      // <img src=\"{ expr }\">\n\t      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n\t        attrName = attrName.slice(RIOT_PREFIX.length)\n\t      }\n\t      setAttr(dom, attrName, value)\n\t    }\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } els - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(els, fn) {\n\t  var len = els ? els.length : 0\n\t\n\t  for (var i = 0, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> current item was removed by fn during the loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is a function\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(v) {\n\t  return typeof v === T_FUNCTION || false   // avoid IE problems\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is an object, exclude null.\n\t * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(v) {\n\t  return v && typeof v === T_OBJECT         // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } string - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(string) {\n\t  return string.replace(/-(\\w)/g, function(_, c) {\n\t    return c.toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  dom.setAttribute(name, val)\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n\t}\n\t/**\n\t * Add a child tag to its parent into the `tags` object\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the new tag will be stored\n\t * @param   { Object } parent - tag instance where the new child tag will be included\n\t */\n\tfunction addChildTag(tag, tagName, parent) {\n\t  var cachedTag = parent.tags[tagName]\n\t\n\t  // if there are multiple children tags having the same name\n\t  if (cachedTag) {\n\t    // if the parent tags property is not yet an array\n\t    // create it adding the first cached tag\n\t    if (!isArray(cachedTag))\n\t      // don't add the same tag twice\n\t      if (cachedTag !== tag)\n\t        parent.tags[tagName] = [cachedTag]\n\t    // add the new nested tag to the array\n\t    if (!contains(parent.tags[tagName], tag))\n\t      parent.tags[tagName].push(tag)\n\t  } else {\n\t    parent.tags[tagName] = tag\n\t  }\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tag, tagName, newPos) {\n\t  var parent = tag.parent,\n\t    tags\n\t  // no parent no move\n\t  if (!parent) return\n\t\n\t  tags = parent.tags[tagName]\n\t\n\t  if (isArray(tags))\n\t    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n\t  else addChildTag(tag, tagName, parent)\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag(child, opts, innerHTML),\n\t    tagName = getTagName(opts.root),\n\t    ptag = getImmediateCustomParentTag(parent)\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent\n\t\n\t  // add this tag to the custom parent tag\n\t  addChildTag(tag, tagName, ptag)\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    addChildTag(tag, tagName, parent)\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = ''\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag\n\t  while (!getTag(ptag.root)) {\n\t    if (!ptag.parent) break\n\t    ptag = ptag.parent\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t* @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: false\n\t  }, options))\n\t  return el\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = getAttr(dom, 'name'),\n\t    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } arr - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } Does 'arr' contain 'item'?\n\t */\n\tfunction contains(arr, item) {\n\t  return ~arr.indexOf(item)\n\t}\n\t\n\t/**\n\t * Check whether an object is a kind of array\n\t * @param   { * } a - anything\n\t * @returns {Boolean} is 'a' an array?\n\t */\n\tfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\t\n\t/**\n\t * Detect whether a property of an object could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } is this property writable?\n\t */\n\tfunction isWritable(obj, key) {\n\t  var props = Object.getOwnPropertyDescriptor(obj, key)\n\t  return typeof obj[key] === T_UNDEF || props && props.writable\n\t}\n\t\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n\t    return data\n\t\n\t  var o = {}\n\t  for (var key in data) {\n\t    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n\t      o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t */\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    // stop the recursion\n\t    if (fn(dom) === false) return\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttributes(html, fn) {\n\t  var m,\n\t    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\t\n\t  while (m = re.exec(html)) {\n\t    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Simple object prototypal inheritance\n\t * @param   { Object } parent - parent object\n\t * @returns { Object } child instance\n\t */\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\t/**\n\t * Get the name property needed to identify a DOM node in riot\n\t * @param   { Object } dom - DOM node we need to parse\n\t * @returns { String | undefined } give us back a string to identify this dom node\n\t */\n\tfunction getNamedKey(dom) {\n\t  return getAttr(dom, 'id') || getAttr(dom, 'name')\n\t}\n\t\n\t/**\n\t * Set the named properties of a tag element\n\t * @param { Object } dom - DOM node we need to parse\n\t * @param { Object } parent - tag instance where the named dom element will be eventually added\n\t * @param { Array } keys - list of all the tag instance properties\n\t */\n\tfunction setNamed(dom, parent, keys) {\n\t  // get the key value we want to add to the tag instance\n\t  var key = getNamedKey(dom),\n\t    isArr,\n\t    // add the node detected to a tag instance using the named property\n\t    add = function(value) {\n\t      // avoid to override the tag properties already set\n\t      if (contains(keys, key)) return\n\t      // check whether this value is an array\n\t      isArr = isArray(value)\n\t      // if the key was never set\n\t      if (!value)\n\t        // set it once on the tag instance\n\t        parent[key] = dom\n\t      // if it was an array and not yet set\n\t      else if (!isArr || isArr && !contains(value, dom)) {\n\t        // add the dom node into the array\n\t        if (isArr)\n\t          value.push(dom)\n\t        else\n\t          parent[key] = [value, dom]\n\t      }\n\t    }\n\t\n\t  // skip the elements with no named properties\n\t  if (!key) return\n\t\n\t  // check whether this key has been already evaluated\n\t  if (tmpl.hasExpr(key))\n\t    // wait the first updated event only once\n\t    parent.one('mount', function() {\n\t      key = getNamedKey(dom)\n\t      add(parent[key])\n\t    })\n\t  else\n\t    add(parent[key])\n\t\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } src - source string\n\t * @param   { String } str - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(src, str) {\n\t  return src.slice(0, str.length) === str\n\t}\n\t\n\t/**\n\t * requestAnimationFrame function\n\t * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n\t */\n\tvar rAF = (function (w) {\n\t  var raf = w.requestAnimationFrame    ||\n\t            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\t\n\t  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n\t    var lastTime = 0\n\t\n\t    raf = function (cb) {\n\t      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n\t      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n\t    }\n\t  }\n\t  return raf\n\t\n\t})(window || {})\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = __tagImpl[tagName],\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n\t  }\n\t\n\t  return tag\n\t}\n\t/**\n\t * Riot public api\n\t */\n\t\n\t// share methods for other riot parts, e.g. compiler\n\triot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t/**\n\t * Create a mixin that could be globally shared across all the tags\n\t */\n\triot.mixin = (function() {\n\t  var mixins = {}\n\t\n\t  /**\n\t   * Create/Return a mixin by its name\n\t   * @param   { String } name - mixin name (global mixin if missing)\n\t   * @param   { Object } mixin - mixin logic\n\t   * @returns { Object } the mixin logic\n\t   */\n\t  return function(name, mixin) {\n\t    if (isObject(name)) {\n\t      mixin = name\n\t      mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin)\n\t      return\n\t    }\n\t\n\t    if (!mixin) return mixins[name]\n\t    mixins[name] = mixin\n\t  }\n\t\n\t})()\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else styleManager.add(css)\n\t  }\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @param   { string }  [bpair] - brackets used in the compilation\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag2 = function(name, html, css, attrs, fn, bpair) {\n\t  if (css) styleManager.add(css)\n\t  //if (bpair) riot.settings.brackets = bpair\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { String } selector - tag DOM selector\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t    allTags,\n\t    tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      if (!/[^-\\w]/.test(e))\n\t        list += ',*[' + RIOT_TAG + '=' + e.trim() + ']'\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(__tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG)\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName\n\t        setAttr(root, RIOT_TAG, tagName)\n\t      }\n\t      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    } else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject()\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(/, ?/))\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    els = selector ? $$(selector) : []\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  pushTags(els)\n\t\n\t  return tags\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\triot.update = function() {\n\t  return each(__virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t/**\n\t * Export the Tag constructor\n\t */\n\triot.Tag = Tag\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (\"function\" === T_FUNCTION && typeof __webpack_require__(/*! !webpack amd options */ 26) !== T_UNDEF)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return riot }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : void 0);\n\n\n/***/ },\n/* 2 */\n/*!**************************************!*\\\n  !*** ./~/css-loader/lib/css-base.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 3 */\n/*!*************************************!*\\\n  !*** ./~/style-loader/addStyles.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0;\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction createStyleElement() {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = getHeadElement();\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement() {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tvar head = getHeadElement();\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\thead.appendChild(linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement();\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement();\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */\n/*!*****************************************!*\\\n  !*** ./~/css-loader!./src/css/grid.css ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".grid{list-style:none;margin-left:-20px}.grid__col--2-of-2,.grid__col--3-of-3,.grid__col--4-of-4,.grid__col--5-of-5,.grid__col--6-of-6,.grid__col--8-of-8,.grid__col--12-of-12{width:100%}.grid__col--1-of-2,.grid__col--2-of-4,.grid__col--3-of-6,.grid__col--4-of-8,.grid__col--6-of-12{width:50%}.grid__col--1-of-3,.grid__col--2-of-6,.grid__col--4-of-12{width:33.33333%}.grid__col--2-of-3,.grid__col--4-of-6,.grid__col--8-of-12{width:66.66667%}.grid__col--1-of-4,.grid__col--2-of-8,.grid__col--3-of-12{width:25%}.grid__col--3-of-4,.grid__col--6-of-8,.grid__col--9-of-12{width:75%}.grid__col--push-2-of-2,.grid__col--push-3-of-3,.grid__col--push-4-of-4,.grid__col--push-5-of-5,.grid__col--push-6-of-6,.grid__col--push-8-of-8,.grid__col--push-12-of-12{margin-left:100%}.grid__col--push-1-of-2,.grid__col--push-2-of-4,.grid__col--push-3-of-6,.grid__col--push-4-of-8,.grid__col--push-6-of-12{margin-left:50%}.grid__col--push-1-of-3,.grid__col--push-2-of-6,.grid__col--push-4-of-12{margin-left:33.33333%}.grid__col--push-2-of-3,.grid__col--push-4-of-6,.grid__col--push-8-of-12{margin-left:66.66667%}.grid__col--push-1-of-4,.grid__col--push-2-of-8,.grid__col--push-3-of-12{margin-left:25%}.grid__col--push-3-of-4,.grid__col--push-6-of-8,.grid__col--push-9-of-12{margin-left:75%}.grid__col--pull-2-of-2,.grid__col--pull-3-of-3,.grid__col--pull-4-of-4,.grid__col--pull-5-of-5,.grid__col--pull-6-of-6,.grid__col--pull-8-of-8,.grid__col--pull-12-of-12{margin-left:-100%}.grid__col--pull-1-of-2,.grid__col--pull-2-of-4,.grid__col--pull-3-of-6,.grid__col--pull-4-of-8,.grid__col--pull-6-of-12{margin-left:-50%}.grid__col--pull-1-of-3,.grid__col--pull-2-of-6,.grid__col--pull-4-of-12{margin-left:-33.33333%}.grid__col--pull-2-of-3,.grid__col--pull-4-of-6,.grid__col--pull-8-of-12{margin-left:-66.66667%}.grid__col--pull-1-of-4,.grid__col--pull-2-of-8,.grid__col--pull-3-of-12{margin-left:-25%}.grid__col--pull-3-of-4,.grid__col--pull-6-of-8,.grid__col--pull-9-of-12{margin-left:-75%}.grid__col--1-of-5{width:20%}.grid__col--push-1-of-5{margin-left:20%}.grid__col--pull-1-of-5{margin-left:-20%}.grid__col--2-of-5{width:40%}.grid__col--push-2-of-5{margin-left:40%}.grid__col--pull-2-of-5{margin-left:-40%}.grid__col--3-of-5{width:60%}.grid__col--push-3-of-5{margin-left:60%}.grid__col--pull-3-of-5{margin-left:-60%}.grid__col--4-of-5{width:80%}.grid__col--push-4-of-5{margin-left:80%}.grid__col--pull-4-of-5{margin-left:-80%}.grid__col--1-of-6{width:16.66667%}.grid__col--push-1-of-6{margin-left:16.66667%}.grid__col--pull-1-of-6{margin-left:-16.66667%}.grid__col--5-of-6{width:83.33333%}.grid__col--push-5-of-6{margin-left:83.33333%}.grid__col--pull-5-of-6{margin-left:-83.33333%}.grid__col--1-of-8{width:12.5%}.grid__col--push-1-of-8{margin-left:12.5%}.grid__col--pull-1-of-8{margin-left:-12.5%}.grid__col--3-of-8{width:37.5%}.grid__col--push-3-of-8{margin-left:37.5%}.grid__col--pull-3-of-8{margin-left:-37.5%}.grid__col--5-of-8{width:62.5%}.grid__col--push-5-of-8{margin-left:62.5%}.grid__col--pull-5-of-8{margin-left:-62.5%}.grid__col--7-of-8{width:87.5%}.grid__col--push-7-of-8{margin-left:87.5%}.grid__col--pull-7-of-8{margin-left:-87.5%}.grid__col--1-of-12{width:8.33333%}.grid__col--push-1-of-12{margin-left:8.33333%}.grid__col--pull-1-of-12{margin-left:-8.33333%}.grid__col--2-of-12{width:16.66667%}.grid__col--push-2-of-12{margin-left:16.66667%}.grid__col--pull-2-of-12{margin-left:-16.66667%}.grid__col--5-of-12{width:41.66667%}.grid__col--push-5-of-12{margin-left:41.66667%}.grid__col--pull-5-of-12{margin-left:-41.66667%}.grid__col--7-of-12{width:58.33333%}.grid__col--push-7-of-12{margin-left:58.33333%}.grid__col--pull-7-of-12{margin-left:-58.33333%}.grid__col--10-of-12{width:83.33333%}.grid__col--push-10-of-12{margin-left:83.33333%}.grid__col--pull-10-of-12{margin-left:-83.33333%}.grid__col--11-of-12{width:91.66667%}.grid__col--push-11-of-12{margin-left:91.66667%}.grid__col--pull-11-of-12{margin-left:-91.66667%}.grid__col{box-sizing:border-box;display:inline-block;margin-right:-.25em;min-height:1px;padding-left:20px;vertical-align:top}@media (max-width:700px){.grid__col{display:block;margin-left:0;margin-right:0;width:auto}}@media (max-width:700px) and (min-width:480px){.grid__col[class*=grid__col--m-]{display:inline-block;margin-right:-.24em}.grid__col.grid__col--m-1-of-2,.grid__col.grid__col--m-2-of-4{width:50%}.grid__col.grid__col--m-1-of-3{width:33.33333%}.grid__col.grid__col--m-2-of-3{width:66.66667%}.grid__col.grid__col--m-1-of-4{width:25%}.grid__col.grid__col--m-3-of-4{width:75%}}@media (max-width:480px){.grid__col[class*=grid__col--s-]{display:inline-block;margin-right:-.24em}.grid__col.grid__col--s-1-of-2,.grid__col.grid__col--s-2-of-4{width:50%}.grid__col.grid__col--s-1-of-3{width:33.33333%}.grid__col.grid__col--s-2-of-3{width:66.66667%}.grid__col.grid__col--s-1-of-4{width:25%}.grid__col.grid__col--s-3-of-4{width:75%}}.grid__col--centered{display:block;margin-left:auto;margin-right:auto}.grid__col--d-first{float:left}.grid__col--d-last{float:right}.grid--no-gutter{margin-left:0;width:100%}.grid--no-gutter .grid__col{padding-left:0}.grid--no-gutter .grid__col--span-all{margin-left:0;width:100%}.grid__col--ab{vertical-align:bottom}.grid__col--am{vertical-align:middle}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 10 */\n/*!******************************************!*\\\n  !*** ./~/css-loader!./src/css/style.css ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"input[type=radio],label{display:inline-block}label{margin-bottom:0}.list-contents,.list-search-header{display:flex;justify-content:center}td>button{margin:0}.create-footer{display:flex;flex-direction:column;align-items:center}.student-preview{list-style-type:none}.export-btn{margin-left:15px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 11 */\n/*!**********************************************!*\\\n  !*** ./~/css-loader!./src/css/tacit.min.css ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:block;max-width:100%;overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{display:block;margin-bottom:14.76px}button,input[type=reset],input[type=submit]{background:#b3b3b3;border-radius:3.6px;color:#fff;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}button:hover,input[type=reset]:hover,input[type=submit]:hover{background:#a6a6a6;color:#bfbfbf}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=file],input[type=month],input[type=number],input[type=password],input[type=phone],input[type=range],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:none;border:0;line-height:29.7px;padding:0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000}h1{font-size:36px;font-weight:500;margin-top:36px}h1,h2{margin-bottom:18px}h2{font-size:25.2px;font-weight:400;margin-top:27px}h3{font-size:18px;margin-top:21.6px}h3,h4,h5,h6{margin-bottom:18px}h4,h5,h6{font-size:36px;margin-top:36px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}b,strong{font-weight:500}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px;margin:0;outline:0;padding:0;text-align:left;vertical-align:baseline}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;max-width:100%;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}footer{margin-top:36px}nav,nav ul{text-align:center}nav ul{list-style:none}nav ul li{display:inline;margin-left:9px;margin-right:9px}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}@-moz-document url-prefix(){fieldset{display:table-cell}}section{width:auto}}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */\n/*!**************************!*\\\n  !*** ./src/css/grid.css ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./grid.css */ 9);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./grid.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./grid.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 24 */\n/*!***************************!*\\\n  !*** ./src/css/style.css ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./style.css */ 10);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./style.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 25 */\n/*!*******************************!*\\\n  !*** ./src/css/tacit.min.css ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./tacit.min.css */ 11);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 26 */\n/*!****************************************!*\\\n  !*** (webpack)/buildin/amd-options.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.bundle.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bdcb643d001a5e21d8e2\n **/","import './css/tacit.min.css'\r\nimport './css/style.css'\r\nimport './css/grid.css'\r\nimport 'riot'\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/vendor.js\n **/","/* Riot v2.3.16, @license MIT */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.16', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice,\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) }\n\n  // extend the object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n     * @param  { String } events - events ids\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(events, fn) {\n        if (typeof fn != 'function')  return el\n\n        onEachEvent(events, function(name, pos) {\n          (callbacks[name] = callbacks[name] || []).push(fn)\n          fn.typed = pos > 0\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given space separated list of `events` listeners\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(events, fn) {\n        if (events == '*' && !fn) callbacks = {}\n        else {\n          onEachEvent(events, function(name) {\n            if (fn) {\n              var arr = callbacks[name]\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) arr.splice(i--, 1)\n              }\n            } else delete callbacks[name]\n          })\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given space separated list of `events` and execute the `callback` at most once\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(events, fn) {\n        function on() {\n          el.off(events, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(events, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to the given space separated list of `events`\n     * @param   { String } events - events ids\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(events) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns\n\n        for (var i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        onEachEvent(events, function(name) {\n\n          fns = slice.call(callbacks[name] || [], 0)\n\n          for (var i = 0, fn; fn = fns[i]; ++i) {\n            if (fn.busy) return\n            fn.busy = 1\n            fn.apply(el, fn.typed ? [name].concat(args) : args)\n            if (fns[i] !== fn) { i-- }\n            fn.busy = 0\n          }\n\n          if (callbacks['*'] && name != '*')\n            el.trigger.apply(el, ['*', name].concat(args))\n\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) {\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href || '')[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  if (hist) { // if a browser\n    path = base + normalize(path)\n    title = title || doc.title\n    // browsers ignores the second parameter `title`\n    shouldReplace\n      ? hist.replaceState(null, title, path)\n      : hist.pushState(null, title, path)\n    // so we need to set it manually\n    doc.title = title\n    routeFound = false\n    emit()\n    return routeFound\n  }\n\n  // Server-side usage: directly execute handlers for the path\n  return central[TRIGGER]('emit', getPathFromBase(path))\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  var href = loc.href || current\n  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    }\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState == 'complete') start(autoExec)\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec) }, 1)\n      })\n    }\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.21\n */\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }'\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ]\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) bp = _cache\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) return _pairs\n\n    var arr = pair.split(' ')\n\n    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n    arr[6] = _rewrite(_pairs[6], arr)\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _cache\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n          continue\n        }\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr)\n        parts.push(s && s.replace(_bp[5], '$1'))\n      else\n        parts.push(s)\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch]\n\n      recch.lastIndex = ix\n      ix = 1\n      while (match = recch.exec(s)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) break\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9])\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  }\n\n  _brackets.hasRaw = function (src) {\n    return _cache[10].test(src)\n  }\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  }\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _cache[9] = _regex(_pairs[9])\n      _cache[10] = _regex(_pairs[10])\n    }\n    cachedBrackets = pair\n  }\n\n  function _setSettings (o) {\n    var b\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = R_STRINGS\n  _brackets.R_MLCOMMS = R_MLCOMMS\n  _brackets.S_QBLOCKS = S_QBLOCKS\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl (str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.haveRaw = brackets.hasRaw\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr (err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create (str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')\n  }\n\n  var\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    },\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/\n\n  function _parseExpr (expr, asText, qstr) {\n\n    if (expr[0] === '=') expr = expr.slice(1)\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch]\n\n      ir.lastIndex = re.lastIndex\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\n  function _wrapExpr (expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos))\n        }\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  _tmpl.version = brackets.version = 'v2.3.21'\n\n  return _tmpl\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\nvar mkdom = (function (checkIE) {\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    reYieldCls  = /<yield\\s+to=[^>]+>[\\S\\s]*?<\\/yield\\s*>\\s*/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    rsYieldSrc  = '<yield\\\\s+to=[\\'\"]@[\\'\"]\\\\s*>([\\\\S\\\\s]*?)</yield\\\\s*>',\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' }\n\n  checkIE = checkIE && checkIE < 10\n  var tblTags = checkIE\n    ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   {string} impl   - Tag implementation with the template and root attributes\n   * @param   {string} [html] - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   {object} [attr] - Plain object where to store the root attributes\n   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n   */\n  function _mkdom(impl, html, attr) {\n\n    var templ = impl.tmpl,\n      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      el = mkEl('div')\n\n    if (!html) html = ''\n\n    if (impl.attrs) attr.attrs = replaceYield(impl.attrs, html)\n\n    // replace all the yield tags with the tag inner html\n    templ = replaceYield(templ, html)\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      el = specialTags(el, templ, tagName)\n    else\n      el.innerHTML = templ\n\n    el.stub = true\n\n    return el\n  }\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, templ, tagName) {\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>'\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n    parent = el.firstChild\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    if (select) {\n      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n    } else {\n      var tname = rootEls[tagName]\n      if (tname && parent.childNodes.length === 1) parent = $(tname, parent)\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(templ, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(templ)) return templ\n\n    // be careful with #1343 - string on the source having `$1`\n    var n = 1\n    templ = templ.replace(reYieldDest, function (_, ref, def) {\n      var m = html.match(RegExp(rsYieldSrc.replace('@', ref), 'i'))\n      n = 0\n      return (m ? m[1] : def) || ''\n    })\n\n    // yield without any \"from\", replace yield in templ with the innerHTML\n    if (n || reHasYield.test(templ)) {\n      if (html) html = html.replace(reYieldCls, '').trim()\n      templ = templ.replace(reYieldAll, function (_, def) {\n        return html || def || ''\n      })\n    }\n\n    return templ\n  }\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length,\n    t\n\n  while (i > j) {\n    t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root, sib\n  tag._virts = []\n  while (el) {\n    sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root, sib, i = 0\n  for (; i < len; i++) {\n    sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = /^option$/i.test(tagName), // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    var i = 0,\n      itemsLength = items.length\n\n    for (; i < itemsLength; i++) {\n      // reorder only if the items are objects\n      var\n        item = items[i],\n        _mustReorder = mustReorder && item instanceof Object && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length || !tags[i]) { // fix 1581\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (\n        pos !== i && _mustReorder &&\n        tags[i] // fix 1581 unable to reproduce it in a test!\n      ) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n    }\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = (function(_riot) {\n\n  if (!window) return { // skip injection on the server\n    add: function () {},\n    inject: function () {}\n  }\n\n  var styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style')\n    setAttr(newNode, 'type', 'text/css')\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]')\n    if (userNode) {\n      if (userNode.id) newNode.id = userNode.id\n      userNode.parentNode.replaceChild(newNode, userNode)\n    }\n    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\n    return newNode\n  })()\n\n  // Create cache and shortcut to the correct property\n  var cssTextProp = styleNode.styleSheet,\n    stylesToInject = ''\n\n  // Expose the style node in a non-modificable property\n  Object.defineProperty(_riot, 'styleNode', {\n    value: styleNode,\n    writable: true\n  })\n\n  /**\n   * Public api\n   */\n  return {\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param   { String } css [description]\n     */\n    add: function(css) {\n      stylesToInject += css\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function() {\n      if (stylesToInject) {\n        if (cssTextProp) cssTextProp.cssText += stylesToInject\n        else styleNode.innerHTML += stylesToInject\n        stylesToInject = ''\n      }\n    }\n  }\n\n})(riot)\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop ||\n                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n                    ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      expressions.push(extend({ dom: dom, expr: val }, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType,\n      attr\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    implAttr = {},\n    propsInSyncWithParent = [],\n    dom\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  dom = mkdom(impl, innerHTML, implAttr)\n  implAttr = implAttr.attrs || ''\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      var val = el.value\n      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && isObject(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    // the updated event will be triggered\n    // once the DOM will be ready and all the reflows are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    if (self.parent)\n      // closes #1599\n      self.parent.one('updated', function() { self.trigger('updated') })\n    else rAF(function() { self.trigger('updated') })\n\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // add global mixin\n    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n    if (globalMixin) self.mixin(globalMixin)\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (implAttr || hasImpl) {\n      walkAttributes(implAttr, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      root = dom.firstChild\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) root = parent.root\n    }\n\n    defineProperty(self, 'root', root)\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __virtualDom.indexOf(self)\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      __virtualDom.splice(tagIndex, 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        if (v.parentNode) v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    delete root._tag\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (!parent) return\n    var evt = isMount ? 'on' : 'off'\n\n    // the loop tags will be always in sync with the parent automatically\n    if (isLoop)\n      parent[evt]('unmount', self.unmount)\n    else\n      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (!root) return\n  root.insertBefore(before, node)\n  root.removeChild(node)\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = !!value\n    else if (value == null)\n      value = ''\n\n    // textarea and text nodes has no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent && dom.nodeValue != value) {\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value                    // #1113\n          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else dom.nodeValue = value\n      }\n      return\n    }\n\n    // #1612: look for changes in dom.value when updating the value\n    if (attrName === 'value') {\n      if (dom.value != value) dom.value = value\n      return\n    }\n\n    // was the expression value still the same?\n    if (expr.value === value) {\n      return\n    }\n    expr.value = value\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted)\n                el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (attrName === 'show') {\n      dom.style.display = value ? '' : 'none'\n\n    } else if (attrName === 'hide') {\n      dom.style.display = value ? 'none' : ''\n\n    } else if (expr.bool) {\n      if (value) {\n        // #1374 <select> <option selected={true}> </select>\n        if (attrName === 'selected' && dom.nodeName === 'OPTION' && parent) {\n          parent.value = dom.value\n        }\n        setAttr(dom, attrName, attrName)\n      }\n\n    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n      // <img src=\"{ expr }\">\n      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n        attrName = attrName.slice(RIOT_PREFIX.length)\n      }\n      setAttr(dom, attrName, value)\n    }\n\n  })\n\n}\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  var len = els ? els.length : 0\n\n  for (var i = 0, el; i < len; i++) {\n    el = els[i]\n    // return false -> current item was removed by fn during the loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Detect if the argument passed is an object, exclude null.\n * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isObject(v) {\n  return v && typeof v === T_OBJECT         // typeof null is 'object'\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n    return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    isArr,\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('mount', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * requestAnimationFrame function\n * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n */\nvar rAF = (function (w) {\n  var raf = w.requestAnimationFrame    ||\n            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\n  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n    var lastTime = 0\n\n    raf = function (cb) {\n      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n    }\n  }\n  return raf\n\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name (global mixin if missing)\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (isObject(name)) {\n      mixin = name\n      mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin)\n      return\n    }\n\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else styleManager.add(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css) styleManager.add(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      if (!/[^-\\w]/.test(e))\n        list += ',*[' + RIOT_TAG + '=' + e.trim() + ']'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG)\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName\n        setAttr(root, RIOT_TAG, tagName)\n      }\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  // inject styles into DOM\n  styleManager.inject()\n\n  if (isObject(tagName)) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(/, ?/))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  pushTags(els)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 2\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 3\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".grid{list-style:none;margin-left:-20px}.grid__col--2-of-2,.grid__col--3-of-3,.grid__col--4-of-4,.grid__col--5-of-5,.grid__col--6-of-6,.grid__col--8-of-8,.grid__col--12-of-12{width:100%}.grid__col--1-of-2,.grid__col--2-of-4,.grid__col--3-of-6,.grid__col--4-of-8,.grid__col--6-of-12{width:50%}.grid__col--1-of-3,.grid__col--2-of-6,.grid__col--4-of-12{width:33.33333%}.grid__col--2-of-3,.grid__col--4-of-6,.grid__col--8-of-12{width:66.66667%}.grid__col--1-of-4,.grid__col--2-of-8,.grid__col--3-of-12{width:25%}.grid__col--3-of-4,.grid__col--6-of-8,.grid__col--9-of-12{width:75%}.grid__col--push-2-of-2,.grid__col--push-3-of-3,.grid__col--push-4-of-4,.grid__col--push-5-of-5,.grid__col--push-6-of-6,.grid__col--push-8-of-8,.grid__col--push-12-of-12{margin-left:100%}.grid__col--push-1-of-2,.grid__col--push-2-of-4,.grid__col--push-3-of-6,.grid__col--push-4-of-8,.grid__col--push-6-of-12{margin-left:50%}.grid__col--push-1-of-3,.grid__col--push-2-of-6,.grid__col--push-4-of-12{margin-left:33.33333%}.grid__col--push-2-of-3,.grid__col--push-4-of-6,.grid__col--push-8-of-12{margin-left:66.66667%}.grid__col--push-1-of-4,.grid__col--push-2-of-8,.grid__col--push-3-of-12{margin-left:25%}.grid__col--push-3-of-4,.grid__col--push-6-of-8,.grid__col--push-9-of-12{margin-left:75%}.grid__col--pull-2-of-2,.grid__col--pull-3-of-3,.grid__col--pull-4-of-4,.grid__col--pull-5-of-5,.grid__col--pull-6-of-6,.grid__col--pull-8-of-8,.grid__col--pull-12-of-12{margin-left:-100%}.grid__col--pull-1-of-2,.grid__col--pull-2-of-4,.grid__col--pull-3-of-6,.grid__col--pull-4-of-8,.grid__col--pull-6-of-12{margin-left:-50%}.grid__col--pull-1-of-3,.grid__col--pull-2-of-6,.grid__col--pull-4-of-12{margin-left:-33.33333%}.grid__col--pull-2-of-3,.grid__col--pull-4-of-6,.grid__col--pull-8-of-12{margin-left:-66.66667%}.grid__col--pull-1-of-4,.grid__col--pull-2-of-8,.grid__col--pull-3-of-12{margin-left:-25%}.grid__col--pull-3-of-4,.grid__col--pull-6-of-8,.grid__col--pull-9-of-12{margin-left:-75%}.grid__col--1-of-5{width:20%}.grid__col--push-1-of-5{margin-left:20%}.grid__col--pull-1-of-5{margin-left:-20%}.grid__col--2-of-5{width:40%}.grid__col--push-2-of-5{margin-left:40%}.grid__col--pull-2-of-5{margin-left:-40%}.grid__col--3-of-5{width:60%}.grid__col--push-3-of-5{margin-left:60%}.grid__col--pull-3-of-5{margin-left:-60%}.grid__col--4-of-5{width:80%}.grid__col--push-4-of-5{margin-left:80%}.grid__col--pull-4-of-5{margin-left:-80%}.grid__col--1-of-6{width:16.66667%}.grid__col--push-1-of-6{margin-left:16.66667%}.grid__col--pull-1-of-6{margin-left:-16.66667%}.grid__col--5-of-6{width:83.33333%}.grid__col--push-5-of-6{margin-left:83.33333%}.grid__col--pull-5-of-6{margin-left:-83.33333%}.grid__col--1-of-8{width:12.5%}.grid__col--push-1-of-8{margin-left:12.5%}.grid__col--pull-1-of-8{margin-left:-12.5%}.grid__col--3-of-8{width:37.5%}.grid__col--push-3-of-8{margin-left:37.5%}.grid__col--pull-3-of-8{margin-left:-37.5%}.grid__col--5-of-8{width:62.5%}.grid__col--push-5-of-8{margin-left:62.5%}.grid__col--pull-5-of-8{margin-left:-62.5%}.grid__col--7-of-8{width:87.5%}.grid__col--push-7-of-8{margin-left:87.5%}.grid__col--pull-7-of-8{margin-left:-87.5%}.grid__col--1-of-12{width:8.33333%}.grid__col--push-1-of-12{margin-left:8.33333%}.grid__col--pull-1-of-12{margin-left:-8.33333%}.grid__col--2-of-12{width:16.66667%}.grid__col--push-2-of-12{margin-left:16.66667%}.grid__col--pull-2-of-12{margin-left:-16.66667%}.grid__col--5-of-12{width:41.66667%}.grid__col--push-5-of-12{margin-left:41.66667%}.grid__col--pull-5-of-12{margin-left:-41.66667%}.grid__col--7-of-12{width:58.33333%}.grid__col--push-7-of-12{margin-left:58.33333%}.grid__col--pull-7-of-12{margin-left:-58.33333%}.grid__col--10-of-12{width:83.33333%}.grid__col--push-10-of-12{margin-left:83.33333%}.grid__col--pull-10-of-12{margin-left:-83.33333%}.grid__col--11-of-12{width:91.66667%}.grid__col--push-11-of-12{margin-left:91.66667%}.grid__col--pull-11-of-12{margin-left:-91.66667%}.grid__col{box-sizing:border-box;display:inline-block;margin-right:-.25em;min-height:1px;padding-left:20px;vertical-align:top}@media (max-width:700px){.grid__col{display:block;margin-left:0;margin-right:0;width:auto}}@media (max-width:700px) and (min-width:480px){.grid__col[class*=grid__col--m-]{display:inline-block;margin-right:-.24em}.grid__col.grid__col--m-1-of-2,.grid__col.grid__col--m-2-of-4{width:50%}.grid__col.grid__col--m-1-of-3{width:33.33333%}.grid__col.grid__col--m-2-of-3{width:66.66667%}.grid__col.grid__col--m-1-of-4{width:25%}.grid__col.grid__col--m-3-of-4{width:75%}}@media (max-width:480px){.grid__col[class*=grid__col--s-]{display:inline-block;margin-right:-.24em}.grid__col.grid__col--s-1-of-2,.grid__col.grid__col--s-2-of-4{width:50%}.grid__col.grid__col--s-1-of-3{width:33.33333%}.grid__col.grid__col--s-2-of-3{width:66.66667%}.grid__col.grid__col--s-1-of-4{width:25%}.grid__col.grid__col--s-3-of-4{width:75%}}.grid__col--centered{display:block;margin-left:auto;margin-right:auto}.grid__col--d-first{float:left}.grid__col--d-last{float:right}.grid--no-gutter{margin-left:0;width:100%}.grid--no-gutter .grid__col{padding-left:0}.grid--no-gutter .grid__col--span-all{margin-left:0;width:100%}.grid__col--ab{vertical-align:bottom}.grid__col--am{vertical-align:middle}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/grid.css\n ** module id = 9\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"input[type=radio],label{display:inline-block}label{margin-bottom:0}.list-contents,.list-search-header{display:flex;justify-content:center}td>button{margin:0}.create-footer{display:flex;flex-direction:column;align-items:center}.student-preview{list-style-type:none}.export-btn{margin-left:15px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/style.css\n ** module id = 10\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:block;max-width:100%;overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{display:block;margin-bottom:14.76px}button,input[type=reset],input[type=submit]{background:#b3b3b3;border-radius:3.6px;color:#fff;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}button:hover,input[type=reset]:hover,input[type=submit]:hover{background:#a6a6a6;color:#bfbfbf}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=file],input[type=month],input[type=number],input[type=password],input[type=phone],input[type=range],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:none;border:0;line-height:29.7px;padding:0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000}h1{font-size:36px;font-weight:500;margin-top:36px}h1,h2{margin-bottom:18px}h2{font-size:25.2px;font-weight:400;margin-top:27px}h3{font-size:18px;margin-top:21.6px}h3,h4,h5,h6{margin-bottom:18px}h4,h5,h6{font-size:36px;margin-top:36px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}b,strong{font-weight:500}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px;margin:0;outline:0;padding:0;text-align:left;vertical-align:baseline}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;max-width:100%;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}footer{margin-top:36px}nav,nav ul{text-align:center}nav ul{list-style:none}nav ul li{display:inline;margin-left:9px;margin-right:9px}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}@-moz-document url-prefix(){fieldset{display:table-cell}}section{width:auto}}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/tacit.min.css\n ** module id = 11\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./grid.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./grid.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./grid.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/css/grid.css\n ** module id = 23\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./style.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/css/style.css\n ** module id = 24\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/css/tacit.min.css\n ** module id = 25\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 26\n ** module chunks = 0\n **/"],"sourceRoot":""}